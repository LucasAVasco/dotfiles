#!/bin/bash
#
# Script to manage hard-code encrypted secrets.

source ~/.config/bash/libs/linux/clipboard.sh
source ~/.config/bash/libs/config_file.sh
source ~/.config/bash/libs/help.sh

help() {
	help_msg_format '\t\t' << EOF
		Manage hard-code encrypted secrets.

			This tool encrypts and decrypt secrets using a pre-configured GPG key. Useful if you need to save some secrets in a script
			(bash, by example). You can encrypt the secret with this script and decrypt it later with the \`secrets-man decrypt\` command.

		USAGE

		secrets-man <command> [arguments]

		COMMANDS
			--help | -h
				Show this help.

			enable
				Enable the secret manager in the current shell.

			is-enabled
				Return 'y' if the secret manager is enabled in the current shell. 'n' otherwise.

			encrypt [secrets-options] [secret]
				Encrypt the secret and show it (clipboard or standard output).

			decrypt [secrets-options] [secret]
				Decrypt the secret and show it (clipboard or standard output).

			add-to-direnv <secrets-options> <secret-environment-variable>
				Add the secrets-man commands to the '.envrc' file in the current shell.

		SECRETS-OPTIONS
			--from-clip
				Read the secret to encrypt/decrypt from the clipboard.

			--to-clip
				Send the encrypted/decrypted secret to the clipboard.

			-c)
				Short for --from-clip --to-clip

			--no-clear-clip
				Do not clear the clipboard after sending the encrypted/decrypted secret.
EOF
}

if [[ "$1" == "--help" || "$1" == "-h" ]]; then
	help
	exit 0
fi

# Configuration files and encrypt/decrypt functions {{{

# Parses the configuration file
config_file=~/.local/share/secret-man/config.conf

if [[ -f "$config_file" ]]; then
	gpg_key=$(config_file_get_key_value "$config_file" '=' 'key')
else
	# Create the configuration file if it does not exists
	mkdir -p $(dirname "$config_file")
	touch "$config_file"
fi

# Exit and show an error if the GPG public key is not configured
exit_if_has_not_gpg_public_key() {
	if [[ -z "$gpg_key" ]]; then
		echo "There are not a GPG key configured." >&2
		exit 1
	fi
}

# Encrypt a text with the GPG public key and encode as base64.
#
# stdin: the text to encrypt.
#
# Return base64 of the encrypted text.
encrypt() {
	exit_if_has_not_gpg_public_key

	gpg --quiet --recipient "$gpg_key" --encrypt | base64 -w0
}

# Decrypt a text (encoded as base64) with the GPG private key and return the original text.
#
# stdin: base64 of the encrypted text.
#
# Return the original text.
decrypt() {
	exit_if_has_not_gpg_public_key

	base64 -d | gpg --quiet --recipient "$gpg_key" --decrypt
}

# Encrypt secret.
#
# $1: the secret to encrypt.
#
# Return the encrypted secret.
encrypt_secret() {
	local secret="$1"

	if [[ -z "$secret" ]]; then
		encrypt # Use standard input
	else
		printf '%s' "$secret" | encrypt
	fi
}

# Decrypt secret.
#
# $1: the secret to decrypt.
#
# Return the decrypted secret.
decrypt_secret() {
	local secret="$1"

	if [[ -z "$secret" ]]; then
		decrypt # Use standard input
	else
		printf '%s' "$secret" | decrypt
	fi
}

# }}}

# Get the path of the '.envrc' file in the current shell
get_direnvrc_file_path() {
	path=$(direnv status --json | jq .state.foundRC.path --join-output)
	if [[ "$path" == 'null' ]]; then
		path=''
	fi

	printf '%s' "$path"
}

# Return if the secret manager is enabled in the current shell
#
# Return 'y' or 'n'
manager_is_enabled () {
	if [[ "$SECRETES_MAN_ENABLED" == 1 ]]; then
		echo -n y
	else
		echo -n n
	fi
}

# Exits and show an error if the secret manager is not enabled
exit_if_manager_is_not_enabled() {
	if [[ $(manager_is_enabled) == n ]]; then
		echo 'you must enable the secret manager by setting the `SECRETES_MAN_ENABLED` environment variable to 1!' >&2
		exit 1
	fi
}

# Main command
command="$1"
shift

# Command arguments
from_clip=n
to_clip=n
clear_clipboard=y
while [[ $# -gt 0 ]]; do
	case "$1" in
		--from-clip)
			from_clip=y
			;;

		--to-clip)
			to_clip=y
			;;

		-c)
			from_clip=y
			to_clip=y
			;;

		--no-clear-clip)
			clear_clipboard=n
			;;

		--)
			shift
			break
			;;

		*)
			break
			;;
	esac

	# Next argument
	shift
done

# Get the secret to process.
#
# $1: the secret if it is not read from the clipboard. If it is read from the clipboard, this argument is ignored.
#
# Return the secret (without any processing).
get_secret() {
	if [[ $from_clip == y ]]; then
		linux_clipboard_paste
	else
		printf '%s' "$1"
	fi
}

# Show the processed secret (send to clipboard or print to the standard output).
#
# $1: the processed secret.
#
# The behavior depends on the command arguments.
show_processed_secret() {
	local processed_secret="$1"

	if [[ $to_clip == y ]]; then
		# Send to the clipboard
		if [[ $clear_clipboard == y ]]; then
			time_wait_before_clear=10
			linux_clipboard_copy --clear "$time_wait_before_clear" -- "$processed_secret"
			echo "Output copied to clipboard. It will be cleared after $time_wait_before_clear seconds."
		else
			linux_clipboard_copy -- "$processed_secret"
		fi
	else
		# Print to the standard output
		printf "%s" "$processed_secret"
	fi
}

# Execute the main command
processed_secret=''
case "$command" in
	enable )
		exit_if_has_not_gpg_public_key

		exit_if_manager_is_not_enabled

		# May need to reload the current shell direnv configuration if this script is used in a '.envrc' file
		file_path=$(get_direnvrc_file_path)
		if [[ -n "$file_path" ]]; then
			direnv reload
		fi
		;;

	is-enabled)
		manager_is_enabled
		;;

	encrypt)
		secret=$(get_secret "$1")
		processed_secret=$(encrypt_secret "$secret")
		show_processed_secret "$processed_secret"
		;;

	decrypt)
		exit_if_manager_is_not_enabled

		secret=$(get_secret "$1")
		processed_secret=$(decrypt_secret "$secret")
		show_processed_secret "$processed_secret"
		;;

	add-to-direnv)
		file_path=$(get_direnvrc_file_path)
		if [[ -z "$file_path" ]]; then
			echo "Can not find a '.envrc' file in the current directory." >&2
			exit 1
		fi

		# Key name of the secret in the '.envrc' file
		key="$1"
		shift

		# Secret to encrypt
		secret=$(get_secret "$1")
		encrypted_secret=$(encrypt_secret "$secret")

		# Exports the secret to the '.envrc' file
		echo "export $key=\$(secrets-man decrypt $encrypted_secret)" >> "$file_path"
		;;

	set-key)
		gpg_key="$1"

		if [[ -z "$gpg_key" ]]; then
			read -s -p "Enter the GPG public key: " gpg_key
		fi

		config_file_set_key_value "$config_file" '=' 'key' "$gpg_key"
		;;

	*)
		echo "Unrecognized command: '$command'" >&2
		exit 1
		;;
esac
